import os
from rdkit import Chem
import subprocess
import shutil
import time

ps = Chem.SmilesParserParams()
ps.removeHs = False


def xyz_to_gaussian_input(xyz_file, output_file, method='UB3LYP', basis_set='6-31G(d,p)', 
                          extra_commands='opt=(calcfc,ts, noeigen) freq=noraman', charge=0, 
                          multiplicity=1, mem='2GB', proc=2):
    """
    Convert an XYZ file to Gaussian 16 input file format.

    Args:
        xyz_file (str): Path to the XYZ file.
        output_file (str): Path to the output Gaussian input file to be created.
        method (str, optional): The method to be used in the Gaussian calculation. Default is 'B3LYP'.
        basis_set (str, optional): The basis set to be used in the Gaussian calculation. Default is '6-31G(d)'.
        mem (str, optional): Amount of memory to allocate for the calculations (default is '2GB').
        proc (int, optional): Number of processor cores to use for the calculations (default is 2).
    """
    filename = xyz_file.split('/')[-1].split('.xyz')[0]

    with open(xyz_file, 'r') as xyz:
        atom_lines = xyz.readlines()[2:]  # Skip the first two lines (number of atoms and comment)

    with open(output_file, 'w') as gaussian_input:
        # Write the route section
        if 'external' in method:
            gaussian_input.write(f'%Chk={filename}.chk\n# {method} {extra_commands}')
        else:
            gaussian_input.write(f'%Chk={filename}.chk\n%nproc={proc}\n%Mem={mem}\n# {method}/{basis_set} {extra_commands}')
        
        # Write the title section
        gaussian_input.write('\n\nTitle\n\n')

        # Write the charge and multiplicity section
        gaussian_input.write(f'{charge} {multiplicity}\n')

        # Write the Cartesian coordinates section
        for line in atom_lines:
            atom_info = line.split()
            element = atom_info[0]
            x, y, z = atom_info[1:4]
            gaussian_input.write(f'{element} {x} {y} {z}\n')

        # Write the blank line and the end of the input file
        gaussian_input.write('\n')

    print(f'Gaussian input file "{output_file}" has been created.')


def write_xyz_file_from_ade_atoms(atoms, filename):
    """
    Write an XYZ file from the ADE atoms object.

    Args:
        atoms: The ADE atoms object.
        filename: The name of the XYZ file to write.
    """
    with open(filename, 'w') as f:
        f.write(str(len(atoms)) + '\n')
        f.write('Generated by write_xyz_file()\n')
        for atom in atoms:
            f.write(f'{atom.atomic_symbol} {atom.coord[0]:.6f} {atom.coord[1]:.6f} {atom.coord[2]:.6f}\n')


def write_final_geometry_to_xyz(log_file_path):
    """
    Extract and write the final geometry from a Gaussian log file to an XYZ file.

    Parameters:
    - log_file_path (str): Path to the Gaussian log file.

    Returns:
    str: Path to the generated XYZ file.
    """
    final_geometry = []
    reading_geometry = False
    after_transition_state_opt = False

    xyz_file_path = os.path.splitext(log_file_path)[0] + ".xyz"

    try:
        with open(log_file_path, 'r') as log_file:
            for line in log_file:
                if 'Stationary point found' in line:
                    after_transition_state_opt = True
                if after_transition_state_opt:
                    if 'Standard orientation' in line:
                        reading_geometry = True
                        final_geometry = []
                    elif reading_geometry:
                        # Lines with atomic coordinates are indented
                        columns = line.split()
                        if len(columns) == 6:
                            try:
                                atom_info = {
                                    'atom': int(columns[0]),
                                    'symbol': int(columns[1]),
                                    'x': float(columns[3]),
                                    'y': float(columns[4]),
                                    'z': float(columns[5])
                                }
                                final_geometry.append(atom_info)
                            except:
                                continue
                        else:
                            if len(final_geometry) != 0 and '-----------------------------' in line:
                                break

        if len(final_geometry) != 0:
            with open(xyz_file_path, 'w') as xyz_file:
                num_atoms = len(final_geometry)
                xyz_file.write(f"{num_atoms}\n")
                xyz_file.write("Final geometry extracted from Gaussian log file\n")
                for atom_info in final_geometry:
                    xyz_file.write(f"{atom_info['symbol']} {atom_info['x']:.6f} {atom_info['y']:.6f} {atom_info['z']:.6f}\n")
    
    except FileNotFoundError:
        print(f"File not found: {log_file_path}")
    
    return xyz_file_path


def run_g16_ts_optimization(file_path):
    """
    Run Gaussian 16 for transition state optimization.

    Parameters:
    - file_path (str): Path to the Gaussian input file.

    Returns:
    str: Path to the Gaussian log file.
    """
    # Run Gaussian 16 using nohup and redirect stderr to /dev/null
    log_file = os.path.splitext(file_path)[0] + ".log"
    out_file = os.path.splitext(file_path)[0] + ".out"
                
    with open(out_file, 'w') as out:
        subprocess.run(
            f"g16 < {file_path} > {log_file}",
            shell=True,
            stdout=out,
            stderr=subprocess.DEVNULL,
        ) 
    
    return log_file


def run_irc(input_file):
    """
    Run IRC (Intrinsic Reaction Coordinate) calculation using Gaussian 16.

    Parameters:
    - input_file (str): Path to the Gaussian input file.

    Returns:
    None
    """
    out_file = f'{input_file[:-4]}.out'
    log_file = f'{input_file[:-4]}.log'

    with open(out_file, 'w') as out:
        subprocess.run(
            f"g16 < {input_file} >> {log_file}",
            shell=True,
            stdout=out,
            stderr=subprocess.DEVNULL,
        )


def copy_final_outputs(work_dir, output_dir):
    """
    Copy final outputs from a working directory to an output directory.

    Parameters:
    - work_dir (str): Path to the working directory.
    - output_dir (str): Path to the output directory.

    Returns:
    None
    """
    os.makedirs(output_dir, exist_ok=True)
    for reaction_dir in os.listdir(work_dir):
        try:
            final_ts_guess_dir = os.path.join(os.path.join(work_dir, reaction_dir), 'final_ts_guess')
            if len(os.listdir(final_ts_guess_dir)) != 0:
                shutil.copytree(final_ts_guess_dir, os.path.join(output_dir, f'final_outputs_{reaction_dir}'))
                shutil.copy(os.path.join(os.path.join(work_dir, reaction_dir), 'rp_geometries/reactants_geometry.xyz'),
                        os.path.join(output_dir, f'final_outputs_{reaction_dir}/'))
                shutil.copy(os.path.join(os.path.join(work_dir, reaction_dir), 'rp_geometries/products_geometry.xyz'),
                        os.path.join(output_dir, f'final_outputs_{reaction_dir}/'))
        except:
            continue


def remove_files_in_directory(directory):
    """
    Remove all files in a directory, keeping the directory structure intact.

    Parameters:
    - directory (str): Path to the directory.

    Returns:
    None
    """
    try:
        # List all items in the directory
        items = os.listdir(directory)

        # Iterate over each item and remove only files
        for item_name in items:
            item_path = os.path.join(directory, item_name)

            if os.path.isfile(item_path):
                os.remove(item_path)
            elif os.path.isdir(item_path):
                continue

    except Exception as e:
        print(f"Error during file removal: {e}")


def get_reaction_list(filename):
    ''' a function that opens a file, reads in every line as a reaction smiles and returns them as a list. '''
    with open(filename, 'r') as f:
        lines = f.readlines()
        reaction_list = [line.rstrip().split() for line in lines]
    return reaction_list


def setup_dir(target_dir):
    """
    Read reaction SMILES from a file and return them as a list.

    Parameters:
    - filename (str): Path to the file containing reaction SMILES.

    Returns:
    list: List of reaction SMILES.
    """
    if target_dir in os.listdir():
        shutil.rmtree(target_dir)
    os.mkdir(target_dir)


def print_statistics(successful_reactions, start_time):
    """
    Print statistics including the number of successful reactions and the time taken.

    Parameters:
    - successful_reactions (list): List of successful reactions.
    - start_time (float): Start time of the process.

    Returns:
    None
    """
    end_time = time.time()
    print(f'Successful reactions: {successful_reactions}')
    print(f'Number of successful reactions: {len(successful_reactions)}')
    print(f'Time taken: {end_time - start_time}')


class NotConverged(Exception):
    def __init__(self, rxn_id):
        message = f'xTB calculation not converged for {rxn_id}...'
        super().__init__(message)


def extract_geom_from_xyz(filename):
    """
    Extract geometry from a XYZ file

    Parameters:
    - filename (str): Path to a XYZ file

    Returns:
    geom (list): Geometry
    """
    
    with open(filename, 'r') as file:
        lines = file.readlines()    

    geom = []
    for line in lines[2:]:
        if line.isspace():
            break
        geom.append(line)

    return geom
    

def extract_geom_from_crest_ensemble(filename, number):
    """
    Extract geometries from a XYZ file with an ensemble of conformers (CREST)

    Parameters:
    - lines (list): Lines of XYZ file
    - number (int): How many conformers

    Return:
    geoms (list): Geometries
    """
    
    with open(filename, 'r') as file:
        lines = file.readlines()

    geoms = []

    num_atoms = int(lines[0])
    lines_ind_xyz = num_atoms + 2

    for i in range(number):
        geom = lines[i*lines_ind_xyz + 2:(i+1)*lines_ind_xyz]
        geoms.append(geom)

    return geoms


def create_input_file_opt_g16(name, geom, charge, multiplicity, mem, proc, extra_commands=None,
                            modredundant=None, splitter=None, functional='UB3LYP', basis_set='6-31G', solvent=None):
    """
    Function to generate input of Gaussian
    Args:
        name (str): final name of the input
        geom (list): list with the coordinates
        charge (int): charge
        multiplicity (int): multiplicity
        mem (str): Specifies the memory requested in the Gaussian16 .com files
        proc (int): number of CPUs
        extra_commands (str): add other commands, example: field=M+N
        modredundant (list): constraints
        splitter (str): separator for the string
        functional (str): functional
        basis_set (str): basis_set
        solvent (str): solvent

    Return:
        Create input file for loose opt
    """

    if not extra_commands:
        extra_commands = ""

    if modredundant:
        modredundant_keyword = ', modredundant)'
    else:
        modredundant_keyword = ")"
    
    if solvent:
        solvent_keyword = f"scrf=(SMD, solvent={solvent})"
    else:
        solvent_keyword = " "

    route_link_opt = f"# {functional} {basis_set} Nosymm {solvent_keyword} {extra_commands} "
    route_link_opt += f"opt=(tight {modredundant_keyword}\n\n"

    coordinates = []

    for atom in geom:
        elements = len(atom.split(splitter))
        if elements == 5:
            label, _, x, y, z = atom.split(splitter)
        else:
            label, x, y, z = atom.split(splitter)
        coordinates.append(f"{label}  {x}  {y}  {z}")

    with open(f"{name}.com", 'w') as file:
        
        file.write(f"%nprocshared={proc}\n")
        file.write(f"%mem={mem}\n")
        file.write(f"{route_link_opt}")
        file.write("opt \n\n")
        file.write(f"{charge} {multiplicity}\n")
        for coordinate in coordinates:
            file.write(f"{coordinate}\n")
        if modredundant:
            file.write('\n')
            for constraint in modredundant:
                file.write(f"{constraint}\n")
        file.write("\n\n")


def extract_g16_energy(filename):
    """
    Extract energy from a Gaussian16 output
    
    Parameters:
    - filename (str): Path to the Gaussian output
    
    Returns:
    - energy (float): Energy
    """
    
    with open(filename, 'r') as file:
        lines = file.readlines()[::-1]
    
    for line in lines:
        
        if 'Error termination' in line:
            return None
        
        if line.startswith(' SCF Done'): 
            energy = float(line.split()[4])
            break

    return energy





if __name__ == '__main__':
   write_final_geometry_to_xyz('logs/ts_guess_2.log')
