import os
from rdkit import Chem
import subprocess
import shutil
import time
import logging

ps = Chem.SmilesParserParams()
ps.removeHs = False


def xyz_to_gaussian_input(xyz_file, output_file, method='UB3LYP', basis_set='6-31G(d,p)', 
                          extra_commands='opt=(calcfc,ts, noeigen) freq=noraman', charge=0, 
                          multiplicity=1, mem='2GB', proc=2):
    """
    Convert an XYZ file to Gaussian 16 input file format.

    Args:
        xyz_file (str): Path to the XYZ file.
        output_file (str): Path to the output Gaussian input file to be created.
        method (str, optional): The method to be used in the Gaussian calculation. Default is 'B3LYP'.
        basis_set (str, optional): The basis set to be used in the Gaussian calculation. Default is '6-31G(d)'.
        mem (str, optional): Amount of memory to allocate for the calculations (default is '2GB').
        proc (int, optional): Number of processor cores to use for the calculations (default is 2).
    """
    filename = xyz_file.split('/')[-1].split('.xyz')[0]

    with open(xyz_file, 'r') as xyz:
        atom_lines = xyz.readlines()[2:]  # Skip the first two lines (number of atoms and comment)

    with open(output_file, 'w') as gaussian_input:
        # Write the route section
        if 'external' in method:
            gaussian_input.write(f'%Chk={filename}.chk\n# {method} {extra_commands}')
        else:
            gaussian_input.write(f'%Chk={filename}.chk\n%nproc={proc}\n%Mem={mem}\n# {method}/{basis_set} {extra_commands}')
        
        # Write the title section
        gaussian_input.write('\n\nTitle\n\n')

        # Write the charge and multiplicity section
        gaussian_input.write(f'{charge} {multiplicity}\n')

        # Write the Cartesian coordinates section
        for line in atom_lines:
            if not line.strip():
                break
            atom_info = line.split()
            element = atom_info[0]
            x, y, z = atom_info[1:4]
            gaussian_input.write(f'{element} {x} {y} {z}\n')

        # Write the blank line and the end of the input file
        gaussian_input.write('\n')

    print(f'Gaussian input file "{output_file}" has been created.')


def write_xyz_file_from_ade_atoms(atoms, filename):
    """
    Write an XYZ file from the ADE atoms object.

    Args:
        atoms: The ADE atoms object.
        filename: The name of the XYZ file to write.
    """
    with open(filename, 'w') as f:
        f.write(str(len(atoms)) + '\n')
        f.write('Generated by write_xyz_file()\n')
        for atom in atoms:
            f.write(f'{atom.atomic_symbol} {atom.coord[0]:.6f} {atom.coord[1]:.6f} {atom.coord[2]:.6f}\n')


def write_final_geometry_to_xyz(log_file_path):
    """
    Extract and write the final geometry from a Gaussian log file to an XYZ file.

    Args:

        - log_file_path (str): Path to the Gaussian log file.

    Returns:

        str: Path to the generated XYZ file.
    """
    final_geometry = []
    reading_geometry = False
    after_transition_state_opt = False

    xyz_file_path = os.path.splitext(log_file_path)[0] + ".xyz"

    try:
        with open(log_file_path, 'r') as log_file:
            for line in log_file:
                if 'Stationary point found' in line:
                    after_transition_state_opt = True
                if after_transition_state_opt:
                    if 'Standard orientation' in line:
                        reading_geometry = True
                        final_geometry = []
                    elif reading_geometry:
                        # Lines with atomic coordinates are indented
                        columns = line.split()
                        if len(columns) == 6:
                            try:
                                atom_info = {
                                    'atom': int(columns[0]),
                                    'symbol': int(columns[1]),
                                    'x': float(columns[3]),
                                    'y': float(columns[4]),
                                    'z': float(columns[5])
                                }
                                final_geometry.append(atom_info)
                            except:
                                continue
                        else:
                            if len(final_geometry) != 0 and '-----------------------------' in line:
                                break

        if len(final_geometry) != 0:
            with open(xyz_file_path, 'w') as xyz_file:
                num_atoms = len(final_geometry)
                xyz_file.write(f"{num_atoms}\n")
                xyz_file.write("Final geometry extracted from Gaussian log file\n")
                for atom_info in final_geometry:
                    xyz_file.write(f"{atom_info['symbol']} {atom_info['x']:.6f} {atom_info['y']:.6f} {atom_info['z']:.6f}\n")
    
    except FileNotFoundError:
        print(f"File not found: {log_file_path}")
    
    return xyz_file_path


def write_xyz_file_from_rdkit_conf(rdkit_mol, filename):
    """
        Write an XYZ file from RDKit molecule.

        Args:

            rdkit_mol: The RDKit molecule object.
            filename: The name of the XYZ file to write.
        """

    xyz_block = Chem.MolToXYZBlock(rdkit_mol, 0)

    with open(filename + '.xyz', 'w') as f:
        for line in xyz_block:
            f.write(line)


def run_g16_ts_optimization(file_path):
    """
    Run Gaussian 16 for transition state optimization.

    Args:

        file_path (str): Path to the Gaussian input file.

    Returns:

        str: Path to the Gaussian log file.
    """
    # Run Gaussian 16 using nohup and redirect stderr to /dev/null
    log_file = os.path.splitext(file_path)[0] + ".log"
    out_file = os.path.splitext(file_path)[0] + ".out"
                
    with open(out_file, 'w') as out:
        subprocess.run(
            f"g16 < {file_path} > {log_file}",
            shell=True,
            stdout=out,
            stderr=subprocess.DEVNULL,
        ) 
    
    return log_file


def run_irc(input_file):
    """
    Run IRC (Intrinsic Reaction Coordinate) calculation using Gaussian 16.

    Args:

        input_file (str): Path to the Gaussian input file.

    Returns:

        None
    """
    out_file = f'{input_file[:-4]}.out'
    log_file = f'{input_file[:-4]}.log'

    with open(out_file, 'w') as out:
        subprocess.run(
            f"g16 < {input_file} >> {log_file}",
            shell=True,
            stdout=out,
            stderr=subprocess.DEVNULL,
        )


def copy_final_outputs(work_dir, output_dir):
    """
    Copy final outputs from a working directory to an output directory.

    Args:

        work_dir (str): Path to the working directory.
        output_dir (str): Path to the output directory.

    Returns:

        None
    """
    os.makedirs(output_dir, exist_ok=True)
    for reaction_dir in os.listdir(work_dir):
        try:
            final_ts_guess_dir = os.path.join(os.path.join(work_dir, reaction_dir), 'final_ts_guess')
            if len(os.listdir(final_ts_guess_dir)) != 0:
                shutil.copytree(final_ts_guess_dir, os.path.join(output_dir, f'final_outputs_{reaction_dir}'))
                shutil.copy(os.path.join(os.path.join(work_dir, reaction_dir), 'rp_geometries/reactants_geometry.xyz'),
                        os.path.join(output_dir, f'final_outputs_{reaction_dir}/'))
                shutil.copy(os.path.join(os.path.join(work_dir, reaction_dir), 'rp_geometries/products_geometry.xyz'),
                        os.path.join(output_dir, f'final_outputs_{reaction_dir}/'))
        except:
            continue


def copy_final_files(work_dir, output_dir):
    """
    Copy final outputs from a working directory to an output directory.

    Args:

        work_dir (str): Path to the working directory.
        output_dir (str): Path to the output directory.
        ts_only (bool): Copy only the TS guess

    Returns:

        None
    """
    os.makedirs(output_dir, exist_ok=True)
    shutil.copy(os.path.join(work_dir, 'rp_geometries/reactants_geometry.xyz'), output_dir)
    shutil.copy(os.path.join(work_dir, 'rp_geometries/products_geometry.xyz'), output_dir)
    final_ts_guess_dir = os.path.join(work_dir, 'final_ts_guess')
    shutil.copytree(final_ts_guess_dir, output_dir, dirs_exist_ok=True)


def copy_files(work_dir, output_dir, extension):
    """
    Copy files from a directory to an output directory.

    Args:

        work_dir (str): Path to the working directory.
        output_dir (str): Path to the output directory.

    Returns:

        None
    """
    os.makedirs(output_dir, exist_ok=True)
    files = os.listdir(work_dir)
    for file in files:
        if extension in file:
            shutil.copy(os.path.join(work_dir, file), output_dir)

def remove_files_in_directory(directory):
    """
    Remove all files in a directory, keeping the directory structure intact.

    Args:

        directory (str): Path to the directory.

    Returns:

        None
    """
    try:
        # List all items in the directory
        items = os.listdir(directory)

        # Iterate over each item and remove only files
        for item_name in items:
            item_path = os.path.join(directory, item_name)

            if os.path.isfile(item_path):
                os.remove(item_path)
            elif os.path.isdir(item_path):
                continue

    except Exception as e:
        print(f"Error during file removal: {e}")


def get_reaction_list(filename):
    '''
    a function that opens a file, reads in every line as a reaction smiles and returns them as a list.
    '''
    with open(filename, 'r') as f:
        lines = f.readlines()
        reaction_list = [line.rstrip().split() for line in lines]
    return reaction_list


def setup_dir(target_dir):
    """
    Read reaction SMILES from a file and return them as a list.

    Args:
    - filename (str): Path to the file containing reaction SMILES.

    Returns:
    list: List of reaction SMILES.
    """
    if target_dir in os.listdir():
        shutil.rmtree(target_dir)
    os.mkdir(target_dir)


def print_statistics(successful_reactions, sub_reactions, start_time):
    """
    Print statistics including the number of successful reactions and the time taken.

    Args:

        successful_reactions (list): List of successful reactions.
        sub_reactions (list): list of the sub reactions constructed based on intermediates found.
        start_time (float): Start time of the process.

    Returns:

        None
    """
    end_time = time.time()
    print(f'Successful reactions: {successful_reactions}')
    print(f'Number of successful reactions: {len(successful_reactions)}')
    print(f'Number of (potentially) stepwise reactions: {int(len(sub_reactions)/2)}')
    print(f'Time taken: {end_time - start_time}')


def write_stepwise_reactions_to_file(stepwise_reactions, input_file):
    input_file_stepwise_reactions = f'{input_file.strip(".txt")}_stepwise.txt'
    with open(input_file_stepwise_reactions, 'w') as f:
        for rxn_id, rxn_smiles in stepwise_reactions:
            if rxn_smiles is not None:
                f.write(f'{rxn_id} {rxn_smiles}\n')
            else:
                continue

    return input_file_stepwise_reactions


class NotConverged(Exception):
    def __init__(self, rxn_id):
        message = f'xTB calculation not converged for {rxn_id}...'
        super().__init__(message)


class DetectedIntermediateException(Exception):
    def __init__(self, message, reaction_smiles1, reaction_smiles2):
        super().__init__(message)  # Pass only the message to the base Exception class
        self.reaction_smiles1 = reaction_smiles1
        self.reaction_smiles2 = reaction_smiles2  

    def __reduce__(self):
        # Return a tuple of (class_name, args) where args are the arguments to recreate the object
        return (self.__class__, (self.args[0], self.reaction_smiles1, self.reaction_smiles2))


class SmilesGenerationException(Exception):
    def __init__(self, message):
        super().__init__(message)


def extract_geom_from_xyz(filename):
    """
    Extract geometry from a XYZ file

    Args:

        filename (str): Path to a XYZ file

    Returns:

        geom (list): Geometry
    """
    
    with open(filename, 'r') as file:
        lines = file.readlines()    

    geom = []
    for line in lines[2:]:
        if line.isspace():
            break
        geom.append(line)

    return geom


def extract_geom_from_g16(filename):
    """
    Extract geometry from a Gaussian log file

    Args:

        filename (str): Path to a Gaussian log file

    Returns:

        geom (list): Geometry
    """

    with open(filename, 'r') as file:
        lines = file.readlines()[::-1]

    block_lines = []
    append_line = False

    for line in lines:
        if (
                r"\\@" in line
                or line.startswith(" @")
                or line.startswith(r" \@")
        ):
            append_line = True

        if append_line:
            #                 Strip off new-lines and spaces
            block_lines.append(line.strip("\n").strip(" "))

        if (
                "Unable to Open any file for archive entry." in line
        ):
            break

    geom_g16 = [split for split in "".join(block_lines[::-1]).split(r"\\")][3]
    geom_g16 = geom_g16.split(f"\\")

    geom = []
    for coord in geom_g16[1:]:
        label, _, x, y, z = coord.split(',')
        geom.append(f" {label}  {x}  {y}  {z}\n")

    return geom
    

def extract_geom_from_crest_ensemble(filename, num_conf):
    """
    Extract geometries from a XYZ file with an ensemble of conformers (CREST)

    Args:
        filename (str): File name of the ensemble of conformers
        num_conf (int): How many conformers

    Return:

        geoms (list): Geometries
    """
    
    with open(filename, 'r') as file:
        lines = file.readlines()

    geoms = []

    num_atoms = int(lines[0])
    lines_ind_xyz = num_atoms + 2

    for i in range(num_conf):
        geom = lines[i*lines_ind_xyz + 2:(i+1)*lines_ind_xyz]
        geoms.append(geom)

    return geoms


def create_input_file_opt_g16(name, geom, charge, multiplicity, mem, proc, extra_commands=None,
                            modredundant=None, splitter=None, functional='UB3LYP', basis_set='6-31G', solvent=None):
    """
    Create input file for optimization with G16

    Args:

        name (str): final name of the input
        geom (list): list with the coordinates
        charge (int): charge
        multiplicity (int): multiplicity
        mem (str): Specifies the memory requested in the Gaussian16 .com files
        proc (int): number of CPUs
        extra_commands (str): add other commands, example: field=M+N
        modredundant (list): constraints
        splitter (str): separator for the string
        functional (str): functional
        basis_set (str): basis_set
        solvent (str): solvent

    Return:

        None
    """

    if not extra_commands:
        extra_commands = ""

    if modredundant:
        modredundant_keyword = ', modredundant)'
    else:
        modredundant_keyword = ")"
    
    if solvent:
        solvent_keyword = f"scrf=(SMD, solvent={solvent})"
    else:
        solvent_keyword = " "

    route_link_opt = f"# {functional} {basis_set} Nosymm {solvent_keyword} {extra_commands} "
    route_link_opt += f"opt=(tight {modredundant_keyword}\n\n"

    coordinates = []

    for atom in geom:
        elements = len(atom.split(splitter))
        if elements == 5:
            label, _, x, y, z = atom.split(splitter)
        else:
            label, x, y, z = atom.split(splitter)
        coordinates.append(f"{label}  {x}  {y}  {z}")

    with open(f"{name}.com", 'w') as file:
        
        file.write(f"%nprocshared={proc}\n")
        file.write(f"%mem={mem}\n")
        file.write(f"{route_link_opt}")
        file.write("opt \n\n")
        file.write(f"{charge} {multiplicity}\n")
        for coordinate in coordinates:
            file.write(f"{coordinate}\n")
        if modredundant:
            file.write('\n')
            for constraint in modredundant:
                file.write(f"{constraint}\n")
        file.write("\n\n")

def create_input_file_sp_g16(name, geom, charge, multiplicity, mem, proc,
                            splitter=None, functional='UB3LYP', basis_set='6-31G', solvent=None):
    """
    Create input file for single-point with G16

    Args:

        name (str): final name of the input
        geom (list): list with the coordinates
        charge (int): charge
        multiplicity (int): multiplicity
        mem (str): Specifies the memory requested in the Gaussian16 .com files
        proc (int): number of CPUs
        splitter (str): separator for the string
        functional (str): functional
        basis_set (str): basis_set
        solvent (str): solvent

    Return:

        None
    """

    if solvent:
        solvent_keyword = f"scrf=(SMD, solvent={solvent})"
    else:
        solvent_keyword = " "

    route_link_sp = f"# {functional} {basis_set} Nosymm {solvent_keyword} \n\n"

    coordinates = []

    for atom in geom:
        elements = len(atom.split(splitter))
        if elements == 5:
            label, _, x, y, z = atom.split(splitter)
        else:
            label, x, y, z = atom.split(splitter)
        coordinates.append(f"{label}  {x}  {y}  {z}")

    with open(f"{name}.com", 'w') as file:

        file.write(f"%nprocshared={proc}\n")
        file.write(f"%mem={mem}\n")
        file.write(f"{route_link_sp}")
        file.write("sp \n\n")
        file.write(f"{charge} {multiplicity}\n")
        for coordinate in coordinates:
            file.write(f"{coordinate}\n")
        file.write("\n\n")


def extract_g16_energy(filename):
    """
    Extract energy from a Gaussian16 output
    
    Args:

        filename (str): Path to the Gaussian output
    
    Returns:

        energy (float): Energy
    """
    
    with open(filename, 'r') as file:
        lines = file.readlines()[::-1]
    
    for line in lines:
        
        if 'Error termination' in line:
            return None
        
        if line.startswith(' SCF Done'): 
            energy = float(line.split()[4])
            break

    return energy


def extract_g16_xtb_energy(filename):
    """
    Extract energy from a Gaussian16 output when xTB is used

    Args:

        filename (str): Path to the Gaussian output

    Returns:

        energy (float): Energy
    """

    with open(filename, 'r') as file:
        lines = file.readlines()[::-1]

    for line in lines:

        if 'Error termination' in line:
            return None

        if line.startswith(' Recovered energy='):
            energy = float(line.split()[2])
            break

    return energy


def create_logger(name='output.log') -> logging.Logger:
    """
    Creates a logger with a stream handler and two file handlers.

    The stream handler prints to the screen depending on the value of `quiet`.
    One file handler (verbose.log) saves all logs, the other (quiet.log) only saves important info.

    Args:

        name: Name the log.

    Return:

        logger.
    """

    logger = logging.getLogger('final.log')
    logger.setLevel(logging.INFO)
    logger.propagate = False

    # create file handler which logs even debug messages
    fh = logging.FileHandler(f'{name}')
    fh.setLevel(logging.DEBUG)
    # create console handler with a higher log level
    ch = logging.StreamHandler()
    ch.setLevel(logging.ERROR)
    # add the handlers to the logger
    logger.addHandler(fh)
    logger.addHandler(ch)

    return logger


def extract_crest_energy():
    """
        Extract energy from the CREST output

        Return:

            energy (float): Energy of the lowest energy conformer.
        """

    with open('crest_best.xyz', 'r') as f:
        lines = f.readlines()

    if len(lines[1].split()) == 1:
        return float(lines[1])
    else:
        return float(lines[1].split()[1])


def extract_xtb_energy(name):
    """
        Extract energy from the xtb output

        Return:

            energy (float): Energy of the lowest energy conformer.
        """

    with open(f'{name}.out', 'r') as f:
        lines = f.readlines()
    
    for line in lines:
        if 'TOTAL ENERGY' in line:
            return float(line.split()[3])

    


def read_active_atoms(file):

    active_atoms = []

    if file:
        with open(file, 'r') as f:
           lines = f.readlines()

        for line in lines:
            i, j = line.split()
            active_atoms.append(i)
            active_atoms.append(j)

        return active_atoms
    else:
        return None


def write_xyz_file_from_geom(coords, filename):
    """
        Write an XYZ file from a list of coordinates.

        Args:
            coords: The coordinates.
            filename: The name of the XYZ file to write.
        """

    with open(filename + '.xyz', 'w') as f:
        f.write(f"{len(coords)}\n\n")
        for coord in coords:
            f.write(coord)
        f.write("\n")


# TODO: What about triplet states?
def get_charge_and_multiplicity(smi):
    """
    Get the charge and multiplicity of the reactant molecule.
    Returns:
    - tuple: (charge, multiplicity)
    """

    mol = Chem.MolFromSmiles(smi, ps)
    charge = Chem.GetFormalCharge(mol)
    total_electrons = 0

    for atom in mol.GetAtoms():
        # Add the atomic number
        total_electrons += atom.GetAtomicNum()
        
    # subtract the net charge
    total_electrons -= charge
    multiplicity = total_electrons % 2 + 1
    return charge, multiplicity


def run_xtb_hessian(name, charge, uhf, proc, solvent, temp):

    if solvent:
        kwd_solvent = f"--alpb {solvent}"
    else:
        kwd_solvent = " "

    command_line = f"xtb {name}.xyz --gfn2 -P {proc} {kwd_solvent}  --chrg {charge} --uhf {uhf} --etemp {temp} --hess > {name}_hess.out "

    with open(f'{name}_hess.out', 'w') as out:
        subprocess.run(command_line, shell=True, stdout=out, stderr=subprocess.DEVNULL,)


def extract_xtb_gibbs_free_energy(name):
    """
        Extract Free gibbs energy from the xtb output

        Return:

            energy (float): Energy of the lowest energy conformer.
        """

    with open(f'{name}.out', 'r') as f:
        lines = f.readlines()
    
    for line in lines:
        if 'TOTAL FREE ENERGY' in line:
            return float(line.split()[4])

    


if __name__ == '__main__':
   write_final_geometry_to_xyz('logs/ts_guess_2.log')

